
# Iterations Varianten √ºber eine Java Liste 

## Iteration √ºber eine `List<Person>` in Java
Dieses Dokument zeigt **alle gebr√§uchlichen M√∂glichkeiten**, 
√ºber eine `List<Person>` zu iterieren, 
um Elemente zu **lesen**, **suchen**, **bearbeiten** oder **l√∂schen**.

---

## Beispielbasis

```java
private final List<Person> personen = new ArrayList<>();
````

---

## 1Ô∏è Klassische for-Schleife (indexbasiert)

Diese Variante gibt dir volle Kontrolle √ºber den Index und erlaubt sicheres Entfernen w√§hrend der Iteration.

```java
for (int i = 0; i < personen.size(); i++) {
    Person p = personen.get(i);
    // Verarbeitung

    if (p.shouldBeDeleted()) {
        personen.remove(i);
        i--; // wichtig bei Remove aber so zu fehleranf√§llig!
    }
}
```

**Vorteile**

* ‚úÖ Entfernen w√§hrend Iteration m√∂glich
* ‚úÖ Zugriff √ºber Index

**Nachteile**

* ‚ö†Ô∏è Weniger elegant
* ‚ö†Ô∏è Manuelle Indexverwaltung n√∂tig

---

## 2Ô∏è Enhanced for-Loop (for-each)

Die for-each-Schleife ist die einfachste und lesbarste Art, √ºber eine Liste zu iterieren.

```java
for (Person p : personen) {
    System.out.println(p.getName());
}
```

**Vorteile**

* ‚úÖ Sehr lesbar
* ‚úÖ Kurz und pr√§gnant

**Nachteile**

* ‚ùå Kein Entfernen oder Hinzuf√ºgen m√∂glich (`ConcurrentModificationException`)

### Erkl√§rung zum Iterator in der Enhanced for Loop:

Warum der Enhanced for-Loop (for-each) beim Entfernen eine Exception wirft

- Der for-each-Loop verwendet intern automatisch einen Iterator, auch wenn man ihn im Code nicht sieht.
Wenn man jedoch direkt personen.remove(p) aufruft, wird die Liste au√üerhalb des Iterators ver√§ndert.

- Der versteckte Iterator l√§uft intern √ºber die Liste.
- Du rufst aber nicht iterator.remove() auf, sondern personen.remove() direkt.
- Dadurch √§ndert sich die interne Struktur der Liste (z. B. Gr√∂√üe, Speicher, modCount in ArrayList).
- Beim n√§chsten Zugriff merkt der Iterator, dass sich die Liste au√üerhalb seiner Kontrolle ver√§ndert hat,
und wirft eine ConcurrentModificationException.

Kurz gesagt:
- Der for-each-Loop ist nur zum Lesen gedacht ‚Äî
- nicht zum Entfernen oder √Ñndern von Elementen.


---

## 3 Iterator

Mit einem `Iterator` kann man sicher Elemente entfernen, w√§hrend man durch die Liste l√§uft.

```java
Iterator<Person> it = personen.iterator();
while (it.hasNext()) {
    Person p = it.next();

    if (p.shouldBeDeleted()) {
        it.remove(); // korrektes Entfernen
    }
}
```

**Vorteile**

* ‚úÖ Sicheres Entfernen w√§hrend Iteration
* ‚úÖ Einfacher als manuelles Indexmanagement

**Nachteile**

* ‚ö†Ô∏è Etwas mehr Schreibaufwand

---

## 4 ListIterator (bidirektional + add)

Der `ListIterator` erlaubt zus√§tzlich das **R√ºckw√§rtslaufen** und **Hinzuf√ºgen von Elementen** w√§hrend der Iteration.

```java
ListIterator<Person> it = personen.listIterator();
while (it.hasNext()) {
    Person p = it.next();

    if (p.shouldBeDeleted()) {
        it.remove();
    }

    if (p.getName().equals("Chris")) {
        it.add(new Person("New User")); // Hinzuf√ºgen w√§hrend der Iteration
    }
}
```

**Vorteile**

* ‚úÖ Entfernen **und** Hinzuf√ºgen m√∂glich
* ‚úÖ Bidirektionales Traversieren

**Nachteile**

* ‚ö†Ô∏è Komplexer als einfacher Iterator

---

## 5 Stream API (Java 8+)

Streams erm√∂glichen eine funktionale Schreibweise f√ºr das Durchlaufen von Listen.

### Lesen und Filtern

```java
personen.stream()
    .filter(p -> p.getAge() > 30)
    .forEach(System.out::println);
```

### L√∂schen (indirekt)

```java
personen.removeIf(p -> p.getAge() > 65);
```

**Vorteile**

* ‚úÖ Modern, deklarativ und sehr lesbar
* ‚úÖ Ideal f√ºr Filterung und Transformation

**Nachteile**

* ‚ùå Kein direktes Entfernen im Stream selbst

---

## 6 removeIf (modern & elegant l√∂schen)

Ein einzelner Aufruf, um alle Elemente zu entfernen, die ein Kriterium erf√ºllen.

```java
personen.removeIf(p -> p.shouldBeDeleted());
```

**Vorteile**

* ‚úÖ Sehr kurz und lesbar
* ‚úÖ Kein Risiko einer `ConcurrentModificationException`
* ‚úÖ Empfohlene Methode zum L√∂schen

**Nachteile**

* ‚ö†Ô∏è Kein Zugriff auf Index w√§hrend der Iteration

---

## 7 forEach (Iterable Default-Methode)

Lambda-basierte Variante f√ºr einfache Verarbeitungsschritte.

```java
personen.forEach(p -> System.out.println(p.getName()));
```

**Vorteile**

* ‚úÖ K√ºrzeste Schreibweise
* ‚úÖ Modern (seit Java 8)

**Nachteile**

* ‚ùå Kein Entfernen oder Hinzuf√ºgen m√∂glich

---

## 8Ô∏è Parallel Stream

Automatische Parallelisierung der Verarbeitung.

```java
personen.parallelStream()
    .forEach(p -> process(p));
```

**Vorteile**

* ‚úÖ Parallelit√§t ohne Thread-Handling
* ‚úÖ Ideal f√ºr CPU-intensive Aufgaben

**Nachteile**

* ‚ö†Ô∏è Nur thread-safe Operationen erlaubt
* ‚ö†Ô∏è Keine √Ñnderungen an der Liste w√§hrenddessen

---

## 9Ô∏è while-Schleife (klassisch)

Alternative zur for-Schleife mit voller Kontrolle.

```java
int index = 0;
while (index < personen.size()) {
    Person p = personen.get(index);
    index++;
}
```

**Vorteile**

* ‚úÖ Kontrollierbare Iteration

**Nachteile**

* ‚ö†Ô∏è Veraltet f√ºr normale Listenverarbeitung

---

## 10 Spliterator (fortgeschritten)

Der `Spliterator` wird haupts√§chlich intern von Streams genutzt.

```java
Spliterator<Person> s = personen.spliterator();
s.forEachRemaining(p -> System.out.println(p.getName()));
```

**Vorteile**

* ‚úÖ F√ºr parallele oder spezialisierte Verarbeitung

**Nachteile**

* ‚öôÔ∏è Selten direkt im Code n√∂tig

---

## √úbersichtstabelle √ºber alle L√∂sungsvarianten

| Methode            | L√∂schen erlaubt | Beschreibung                          |
| ------------------ | --------------- | ------------------------------------- |
| for-Loop           | ‚úÖ               | Klassiker, volle Kontrolle √ºber Index |
| for-each           | ‚ùå               | Einfach, aber nicht zum Entfernen     |
| Iterator           | ‚úÖ               | Sicheres Entfernen                    |
| ListIterator       | ‚úÖ               | Entfernen + Hinzuf√ºgen m√∂glich        |
| Stream             | ‚ùå               | Nur lesen/verarbeiten                 |
| removeIf()         | ‚úÖ‚úÖ‚úÖ             | Modern und effizient zum L√∂schen      |
| forEach() (Lambda) | ‚ùå               | F√ºr Ausgabe/Verarbeitung              |
| parallelStream()   | ‚ö†Ô∏è              | Nur thread-safe Operationen           |
| while()            | ‚úÖ               | Alternative zur for-Schleife          |
| Spliterator        | ‚öôÔ∏è              | F√ºr komplexe oder parallele Szenarien |

---

## Empfehlungen und Tipps

| Anwendungsfall               | Empfohlene Methode                    |
| ---------------------------- | ------------------------------------- |
| Nur Lesen / Ausgabe          | `for-each`, `forEach`, `Stream`       |
| Suchen nach Element          | `Stream.filter().findFirst()`         |
| L√∂schen w√§hrend Iteration    | `Iterator.remove()` oder `removeIf()` |
| Hinzuf√ºgen w√§hrend Iteration | `ListIterator.add()`                  |
| Parallelverarbeitung         | `parallelStream()` (thread-safe)      |

---

## üß† Fazit

* F√ºr **Lesen/Verarbeiten**: `forEach()` oder `Stream`
* F√ºr **sicheres Entfernen**: `Iterator.remove()` oder `removeIf()`
* F√ºr **Erg√§nzen w√§hrend Iteration**: `ListIterator.add()`
* F√ºr **moderne Schreibweise**: bevorzugt `removeIf()` und Streams

---

¬© 2018 bis 2025 CGS IT Solutions GmbH
*Java Trainingsmaterial / List Iteration Guide*

```

